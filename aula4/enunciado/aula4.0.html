<html>

<head>
    <style>
        body {
            color: black;
            font-family: Arial;
            line-height: 1.6;
        }

        h1 {
            color: #006600;
        }

        h2 {
            color: #003366;
        }

        h3 {
            color: #444;
        }

        hr {
            margin: 20px 0;
        }

        b {
            background-color: #f0f0f0;
            padding: 2px 4px;
        }

        i {
            color: #555;
        }

        pre {
            background-color: #f0f0f0;
            padding: 10px;
        }

        ul {
            margin-left: 20px;
        }

        .Dica {
            background: #f9f9f9;
            border-left: 4px solid #006600;
            padding: 8px;
            margin: 10px 0;
            font-size: 0.95em;
        }
    </style>
</head>

<body>

<h1>Exercícios Guiados — OOP em TypeScript  
(Sistema de Gestão de Projetos)</h1>

<p>
<b>Objetivo:</b><br>
Construir um sistema funcional de gestão de projetos semelhante ao ClickUp,
aplicando conceitos reais de engenharia de software:
<b>encapsulamento</b>, <b>interfaces</b>, <b>herança</b>, 
<b>classes abstratas</b>, <b>polimorfismo</b>, arquitetura modular
e separação de responsabilidades.
</p>

<hr>

<h2>Estrutura final do projeto</h2>

<pre>
src/
│
├─ models/
├─ tasks/
├─ security/
├─ services/
├─ logs/
├─ notifications/
├─ ui/
├─ utils/
├─ main.ts
└─ tsconfig.json
</pre>

<div class="Dica">
<b>Dica:</b> Cada pasta representa um domínio do sistema (uma área do negócio).
</div>

<hr>

<h2>Exercício 1 — Classe base comum</h2>
<p><b>Ficheiro:</b> <i>models/BaseEntity.ts</i></p>

<div class="Dica">
<b>Dica:</b> Esta classe representa dados comuns a todas as entidades.
Pensa em propriedades e comportamentos que todos os objetos do sistema podem ter.
</div>

<pre>
export class BaseEntity {
    protected id: number;
    protected createdAt: Date;

    constructor(id: number) {
        // TODO: inicializar id e createdAt
    }

    getId(): number {
        // TODO
    }

    getCreatedAt(): Date {
        // TODO
    }
}
</pre>

<hr>

<h2>Exercício 2 — Herança em User</h2>
<p><b>Ficheiro:</b> <i>models/UserClass.ts</i></p>

<div class="Dica">
<b>Dica:</b> User herda de BaseEntity.  
Não repliques lógica que já existe na classe base.  
Usa <code>super()</code> para inicializar a parte herdada.
</div>

<pre>
import { BaseEntity } from './BaseEntity';
import { UserRole } from '../security/UserRole';

export class UserClass extends BaseEntity {

    private email: string;
    private active: boolean;
    private role: UserRole;

    constructor(id: number, email: string, role: UserRole) {
        super(id);
        // TODO: inicializar propriedades
    }

    isActive(): boolean {
        // TODO
    }

    toggleActive(): void {
        // TODO
    }

    getRole(): UserRole {
        // TODO
    }
}
</pre>

<hr>

<h2>Exercício 3 — Encapsulamento e validação</h2>

<div class="Dica">
<b>Dica:</b>
<ul>
<li>Usa <code>get</code> e <code>set</code> para controlar acesso</li>
<li>Valida dados antes de guardar</li>
<li>Não permitir estados inválidos</li>
<li>As propriedades privadas não devem ser alteradas diretamente</li>
</ul>
</div>

<pre>
// TODO:
// - Criar getters
// - Criar setters
// - Validar email
// - Impedir valores inválidos
// - Bloquear alteração direta de propriedades privadas
</pre>

<hr>

<h2>Exercício 4 — Interface de Tarefa</h2>
<p><b>Ficheiro:</b> <i>tasks/ITask.ts</i></p>

<div class="Dica">
<b>Dica:</b> Interface = contrato.  
Todas as tarefas devem cumprir esta estrutura e estes métodos.
</div>

<pre>
import { TaskStatus } from './TaskStatus';

export interface ITask {
    id: number;
    title: string;
    completed: boolean;
    status: TaskStatus;

    getType(): string;
    moveTo(status: TaskStatus): void;
}
</pre>

<hr>

<h2>Exercício 5 — Enum de estados de tarefa</h2>
<p><b>Ficheiro:</b> <i>tasks/TaskStatus.ts</i></p>

<div class="Dica">
<b>Dica:</b> Enum representa o workflow da tarefa (ciclo de vida).
</div>

<pre>
export enum TaskStatus {
    CREATED,
    ASSIGNED,
    IN_PROGRESS,
    BLOCKED,
    COMPLETED,
    ARCHIVED
}
</pre>

<hr>

<h2>Exercício 6 — Implementação concreta de Task</h2>
<p><b>Ficheiro:</b> <i>tasks/BugTask.ts</i></p>

<div class="Dica">
<b>Dica:</b>
<ul>
<li>BugTask é um tipo específico de tarefa</li>
<li>Implementa ITask</li>
<li>Define regras próprias de transição</li>
<li>Pensa em regras de negócio realistas</li>
</ul>
</div>

<pre>
import { ITask } from './ITask';
import { TaskStatus } from './TaskStatus';

export class BugTask implements ITask {

    id: number;
    title: string;
    completed: boolean;
    status: TaskStatus;

    constructor(id: number, title: string) {
        // TODO: inicializar propriedades
    }

    getType(): string {
        // TODO: retornar "bug"
    }

    moveTo(status: TaskStatus): void {
        // TODO:
        // - validar transição
        // - atualizar estado
        // - marcar completed se necessário
    }
}
</pre>

<hr>

<h2>Exercício 7 — Polimorfismo funcional</h2>
<p><b>Ficheiro:</b> <i>tasks/taskUtils.ts</i></p>

<div class="Dica">
<b>Dica (comportamento por tipo de tarefa):</b>

<ul>
<li><b>bug</b> → regras mais rígidas, mais validações, logs automáticos, mais notificações</li>
<li><b>feature</b> → regras mais flexíveis, menos validações</li>
<li><b>task</b> → comportamento genérico</li>
</ul>

<p>
<b>Ideia principal:</b><br>
Tipos diferentes de tarefas representam problemas diferentes,  
logo o sistema deve tratá-los de forma diferente.
</p>

<p>
<b>Objetivo do exercício:</b><br>
Uma função genérica que muda de comportamento conforme o tipo da tarefa
</p>
</div>


<pre>
import { ITask } from './ITask';

export function processTask(task: ITask) {
    // TODO:
    // - usar getType()
    // - aplicar lógic<div class="Dica">
<b>Dica (comportamento por tipo de tarefa):</b>

<ul>
<li><b>bug</b> → regras mais rígidas, mais validações, logs automáticos, mais notificações</li>
<li><b>feature</b> → regras mais flexíveis, menos validações</li>
<li><b>task</b> → comportamento genérico</li>
</ul>

<p>
<b>Ideia principal:</b><br>
Tipos diferentes de tarefas representam problemas diferentes,  
logo o sistema deve tratá-los de forma diferente.
</p>

<p>
<b>Objetivo do exercício:</b><br>
Uma função genérica que muda de comportamento conforme o tipo da tarefa,
sem saber qual é a classe concreta.
</p>
</div>
a diferente conforme tipo
}
</pre>

<hr>

<h2>Exercício 8 — Sistema de permissões</h2>

<div class="Dica">
<b>Dica:</b>  
Define regras simples por role:
quem pode criar, editar, apagar, atribuir tarefas.
</div>

<pre>
export enum UserRole {
    ADMIN,
    MANAGER,
    MEMBER,
    VIEWER
}
</pre>

<pre>
import { UserRole } from './UserRole';

export function canCreateTask(role: UserRole): boolean {
    // TODO
}

export function canEditTask(role: UserRole): boolean {
    // TODO
}

export function canDeleteTask(role: UserRole): boolean {
    // TODO
}

export function canAssignTask(role: UserRole): boolean {
    // TODO
}
</pre>

<hr>

<h2>Exercício 9 — Histórico de alterações</h2>

<div class="Dica">
<b>Dica:</b>
<ul>
<li>Regista ações importantes</li>
<li>Guarda mensagens de eventos</li>
<li>Pensa em auditoria de sistema</li>
</ul>
</div>

<pre>
export class HistoryLog {

    private logs: string[] = [];

    addLog(message: string) {
        // TODO
    }

    getLogs(): string[] {
        // TODO
    }

    clearLogs() {
        // TODO
    }
}
</pre>

<hr>

<h2>Exercício 10 — Sistema de notificações</h2>

<div class="Dica">
<b>Dica:</b>
<ul>
<li>Simular sistema real</li>
<li>Separar notificação da lógica principal</li>
<li>Por agora pode ser console.log()</li>
</ul>
</div>

<pre>
export class NotificationService {

    notifyUser(userId: number, message: string) {
        // TODO
    }

    notifyGroup(userIds: number[], message: string) {
        // TODO
    }

    notifyAdmins(message: string) {
        // TODO
    }
}
</pre>

<hr>

<h2>Objetivo final do sistema</h2>

<ul>
<li>Gestão de utilizadores</li>
<li>Gestão de tarefas</li>
<li>Workflow</li>
<li>Permissões</li>
<li>Regras de negócio</li>
<li>Histórico</li>
<li>Notificações</li>
<li>Polimorfismo real</li>
<li>Arquitetura modular</li>
<li>Encapsulamento real</li>
<li>Separação de responsabilidades</li>
<li>Projeto escalável</li>
</ul>

</body>
</html>
